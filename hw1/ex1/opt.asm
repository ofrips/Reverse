; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.60610.1 

	TITLE	D:\Technion\rev4\homeworks\hw1\vs\main\main\Source.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_04OBJILMNO@A?5st?$AA@			; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0DH@PFMIMKOJ@A?5string?5hjdhkjdhkdjhdkjhdkjhd?5d@ ; `string'
PUBLIC	??_C@_03PMGGPEJJ@?$CFd?6?$AA@			; `string'
EXTRN	__imp__getchar:PROC
EXTRN	__imp__printf:PROC
EXTRN	__imp__gets:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
CONST	SEGMENT
??_C@_03PMGGPEJJ@?$CFd?6?$AA@ DB '%d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@PFMIMKOJ@A?5string?5hjdhkjdhkdjhdkjhdkjhd?5d@
CONST	SEGMENT
??_C@_0DH@PFMIMKOJ@A?5string?5hjdhkjdhkdjhdkjhdkjhd?5d@ DB 'A string hjdh'
	DB	'kjdhkdjhdkjhdkjhd dkjhdkhdkjdhkdjhdkjhdkj', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OBJILMNO@A?5st?$AA@
CONST	SEGMENT
??_C@_04OBJILMNO@A?5st?$AA@ DB 'A st', 00H		; `string'
CONST	ENDS
PUBLIC	_main
PUBLIC	?q5@@YAHXZ					; q5
PUBLIC	?q4@@YAHXZ					; q4
PUBLIC	?q3@@YAHXZ					; q3
PUBLIC	?q2@@YAHXZ					; q2
PUBLIC	?q1@@YAHXZ					; q1
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Ogtp
; File d:\technion\rev4\homeworks\hw1\vs\main\main\source.cpp
;	COMDAT ?q1@@YAHXZ
_TEXT	SEGMENT
_str$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
?q1@@YAHXZ PROC						; q1, COMDAT

; 16   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 17   : 	char str[200]={0};

	push	199					; 000000c7H
	lea	eax, DWORD PTR _str$[ebp+1]
	push	0
	push	eax
	mov	BYTE PTR _str$[ebp], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 18   : 
; 19   : 	TWONOPS

	npad	1
	npad	1

; 20   : 	strcpy(str, "A st");

	mov	eax, DWORD PTR ??_C@_04OBJILMNO@A?5st?$AA@
	mov	DWORD PTR _str$[ebp], eax
	mov	al, BYTE PTR ??_C@_04OBJILMNO@A?5st?$AA@+4
	mov	BYTE PTR _str$[ebp+4], al

; 21   : 	TWONOPS

	npad	1
	npad	1

; 22   : 
; 23   : 	printf("%s\n", str); // Protects against removal of strcpy by the optimizer, but not part of your exercise

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	call	DWORD PTR __imp__printf

; 24   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	add	esp, 8
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?q1@@YAHXZ ENDP						; q1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\technion\rev4\homeworks\hw1\vs\main\main\source.cpp
;	COMDAT ?q2@@YAHXZ
_TEXT	SEGMENT
_str$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
?q2@@YAHXZ PROC						; q2, COMDAT

; 27   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 28   : 	char str[200]={0};

	push	199					; 000000c7H
	lea	eax, DWORD PTR _str$[ebp+1]
	push	0
	push	eax
	mov	BYTE PTR _str$[ebp], 0
	call	_memset

; 29   : 	int rc;
; 30   : 
; 31   : 	gets(str); // Seeting str in an opimizer-safe way, but not part of your exercise

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	call	DWORD PTR __imp__gets
	add	esp, 16					; 00000010H

; 32   : 
; 33   : 	TWONOPS

	npad	1
	npad	1

; 34   : 	rc=strcmp(str, "A string hjdhkjdhkdjhdkjhdkjhd dkjhdkhdkjdhkdjhdkjhdkj");

	mov	eax, OFFSET ??_C@_0DH@PFMIMKOJ@A?5string?5hjdhkjdhkdjhdkjhdkjhd?5d@
	lea	ecx, DWORD PTR _str$[ebp]
	npad	6
$LL3@q2:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN4@q2
	test	dl, dl
	je	SHORT $LN5@q2
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN4@q2
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL3@q2
$LN5@q2:
	xor	eax, eax
	jmp	SHORT $LN6@q2
$LN4@q2:
	sbb	eax, eax
	or	eax, 1
$LN6@q2:

; 35   : 	TWONOPS

	npad	1
	npad	1

; 36   : 
; 37   : 	printf("%d\n", rc); // Protects against removal of strcmp by the optimizer, but not part of your exercise

	push	eax
	push	OFFSET ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
	call	DWORD PTR __imp__printf

; 38   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	add	esp, 8
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?q2@@YAHXZ ENDP						; q2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\technion\rev4\homeworks\hw1\vs\main\main\source.cpp
;	COMDAT ?q3@@YAHXZ
_TEXT	SEGMENT
_str$ = -404						; size = 200
_src$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
?q3@@YAHXZ PROC						; q3, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 404				; 00000194H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 44   : 	char str[200]={0};

	push	199					; 000000c7H
	lea	eax, DWORD PTR _str$[ebp+1]
	push	0
	push	eax
	mov	BYTE PTR _str$[ebp], 0
	call	_memset

; 45   : 	char src[200]={0};

	push	199					; 000000c7H
	lea	eax, DWORD PTR _src$[ebp+1]
	push	0
	push	eax
	mov	BYTE PTR _src$[ebp], 0
	call	_memset

; 46   : 
; 47   : 	gets(src); // Seeting str in an opimizer-safe way, but not part of your exercise

	lea	eax, DWORD PTR _src$[ebp]
	push	eax
	call	DWORD PTR __imp__gets
	add	esp, 28					; 0000001cH

; 48   : 
; 49   : 	TWONOPS

	npad	1
	npad	1

; 50   : 	memcpy(str, src, 200);

	mov	ecx, 50					; 00000032H
	lea	esi, DWORD PTR _src$[ebp]
	lea	edi, DWORD PTR _str$[ebp]
	rep movsd

; 51   : 	TWONOPS

	npad	1
	npad	1

; 52   : 
; 53   : 	printf("%s\n", str); // Protects against removal of strcpy by the optimizer, but not part of your exercise

	lea	eax, DWORD PTR _str$[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	call	DWORD PTR __imp__printf

; 54   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	xor	ecx, ebp
	pop	edi
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?q3@@YAHXZ ENDP						; q3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\technion\rev4\homeworks\hw1\vs\main\main\source.cpp
;	COMDAT ?q4@@YAHXZ
_TEXT	SEGMENT
?q4@@YAHXZ PROC						; q4, COMDAT

; 59   : {

	push	esi
	push	edi

; 60   :     int i; 
; 61   : 	int rc=0;

	xor	ecx, ecx

; 62   : 
; 63   : 	TWONOPS

	npad	1
	npad	1

; 64   : 	for(i=0; i<100; i++)

	xor	eax, eax
	xor	edx, edx
	xor	esi, esi
	xor	edi, edi
	npad	2
$LL3@q4:

; 65   : 		rc += i;

	inc	edi
	add	esi, 2
	add	edx, 3
	add	ecx, eax
	add	edi, eax
	add	esi, eax
	add	edx, eax
	add	eax, 4
	cmp	eax, 100				; 00000064H
	jl	SHORT $LL3@q4

; 66   : 	TWONOPS

	lea	eax, DWORD PTR [edx+esi]
	add	eax, edi
	add	ecx, eax
	npad	1
	npad	1

; 67   : 
; 68   : 	printf("%d\n", rc); // Protects against removal of strlen by the optimizer, but not part of your exercise

	push	ecx
	push	OFFSET ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8
	pop	edi
	pop	esi

; 69   : }

	ret	0
?q4@@YAHXZ ENDP						; q4
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\technion\rev4\homeworks\hw1\vs\main\main\source.cpp
;	COMDAT ?q5@@YAHXZ
_TEXT	SEGMENT
?q5@@YAHXZ PROC						; q5, COMDAT

; 74   :     int i; 
; 75   : 	int rc=0;
; 76   : 
; 77   : 	i=getchar();

	call	DWORD PTR __imp__getchar

; 78   : 
; 79   : 	TWONOPS

	npad	1
	npad	1

; 80   : 	switch (i)

	add	eax, -48				; ffffffd0H
	cmp	eax, 69					; 00000045H
	ja	SHORT $LN1@q5
	movzx	eax, BYTE PTR $LN18@q5[eax]
	jmp	DWORD PTR $LN20@q5[eax*4]
$LN13@q5:

; 81   : 	{
; 82   : 	case 'A':
; 83   : 		rc=1;

	mov	eax, 1

; 84   : 		break;

	jmp	SHORT $LN14@q5
$LN12@q5:

; 85   : 	case 'B':
; 86   : 		rc=9;

	mov	eax, 9

; 87   : 		break;

	jmp	SHORT $LN14@q5
$LN11@q5:

; 88   : 	case 'C':
; 89   : 		rc=8;

	mov	eax, 8

; 90   : 		break;

	jmp	SHORT $LN14@q5
$LN10@q5:

; 91   : 	case 'E':
; 92   : 		rc=7;

	mov	eax, 7

; 93   : 		break;

	jmp	SHORT $LN14@q5
$LN9@q5:

; 94   : 	case 'G':
; 95   : 		rc=6;

	mov	eax, 6

; 96   : 		break;

	jmp	SHORT $LN14@q5
$LN8@q5:

; 97   : 	case 'D':
; 98   : 		rc=5;

	mov	eax, 5

; 99   : 		break;

	jmp	SHORT $LN14@q5
$LN7@q5:

; 100  : 	case 'a':
; 101  : 		rc=4;

	mov	eax, 4

; 102  : 		break;

	jmp	SHORT $LN14@q5
$LN6@q5:

; 103  : 	case 'k':
; 104  : 		rc=11;

	mov	eax, 11					; 0000000bH

; 105  : 		break;

	jmp	SHORT $LN14@q5
$LN2@q5:

; 106  : 	case '0':
; 107  : 		rc=9;
; 108  : 		break;
; 109  : 	case '2':
; 110  : 		rc=9;
; 111  : 		break;
; 112  : 	case 'u':
; 113  : 		rc=9;
; 114  : 		break;
; 115  : 	case 'Z':
; 116  : 		rc=2;

	mov	eax, 2

; 117  : 		break;

	jmp	SHORT $LN14@q5
$LN1@q5:

; 118  : 	default:
; 119  : 		rc=30;

	mov	eax, 30					; 0000001eH
$LN14@q5:

; 120  : 		break;
; 121  : 	}
; 122  : 	TWONOPS

	npad	1
	npad	1

; 123  : 
; 124  : 	printf("%d\n", rc); // Protects against removal of strlen by the optimizer, but not part of your exercise

	push	eax
	push	OFFSET ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 125  : }

	ret	0
$LN20@q5:
	DD	$LN12@q5
	DD	$LN13@q5
	DD	$LN11@q5
	DD	$LN8@q5
	DD	$LN10@q5
	DD	$LN9@q5
	DD	$LN2@q5
	DD	$LN7@q5
	DD	$LN6@q5
	DD	$LN1@q5
$LN18@q5:
	DB	0
	DB	9
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	0
	DB	2
	DB	3
	DB	4
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	7
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	8
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	0
?q5@@YAHXZ ENDP						; q5
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\technion\rev4\homeworks\hw1\vs\main\main\source.cpp
;	COMDAT _main
_TEXT	SEGMENT
_str$1 = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 127  : int main() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 17   : 	char str[200]={0};

	push	199					; 000000c7H
	lea	eax, DWORD PTR _str$1[ebp+1]
	push	0
	push	eax
	mov	BYTE PTR _str$1[ebp], 0
	call	_memset
	add	esp, 12					; 0000000cH

; 18   : 
; 19   : 	TWONOPS

	npad	1
	npad	1

; 20   : 	strcpy(str, "A st");

	mov	eax, DWORD PTR ??_C@_04OBJILMNO@A?5st?$AA@
	mov	DWORD PTR _str$1[ebp], eax
	mov	al, BYTE PTR ??_C@_04OBJILMNO@A?5st?$AA@+4
	mov	BYTE PTR _str$1[ebp+4], al

; 21   : 	TWONOPS

	npad	1
	npad	1

; 22   : 
; 23   : 	printf("%s\n", str); // Protects against removal of strcpy by the optimizer, but not part of your exercise

	lea	eax, DWORD PTR _str$1[ebp]
	push	eax
	push	OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 128  : 		q1();
; 129  : 		q2();

	call	?q2@@YAHXZ				; q2

; 130  : 		q3();

	call	?q3@@YAHXZ				; q3

; 24   : }
; 25   : 
; 26   : int q2()
; 27   : {
; 28   : 	char str[200]={0};
; 29   : 	int rc;
; 30   : 
; 31   : 	gets(str); // Seeting str in an opimizer-safe way, but not part of your exercise
; 32   : 
; 33   : 	TWONOPS
; 34   : 	rc=strcmp(str, "A string hjdhkjdhkdjhdkjhdkjhd dkjhdkhdkjdhkdjhdkjhdkj");
; 35   : 	TWONOPS
; 36   : 
; 37   : 	printf("%d\n", rc); // Protects against removal of strcmp by the optimizer, but not part of your exercise
; 38   : }
; 39   : 
; 40   : 
; 41   : 
; 42   : int q3()
; 43   : {
; 44   : 	char str[200]={0};
; 45   : 	char src[200]={0};
; 46   : 
; 47   : 	gets(src); // Seeting str in an opimizer-safe way, but not part of your exercise
; 48   : 
; 49   : 	TWONOPS
; 50   : 	memcpy(str, src, 200);
; 51   : 	TWONOPS
; 52   : 
; 53   : 	printf("%s\n", str); // Protects against removal of strcpy by the optimizer, but not part of your exercise
; 54   : }
; 55   : 
; 56   : 
; 57   : 
; 58   : int q4()
; 59   : {
; 60   :     int i; 
; 61   : 	int rc=0;

	xor	ecx, ecx

; 62   : 
; 63   : 	TWONOPS

	npad	1
	npad	1

; 64   : 	for(i=0; i<100; i++)

	xor	eax, eax
	xor	edx, edx
	xor	esi, esi
	xor	edi, edi
$LL7@main:

; 65   : 		rc += i;

	inc	edi
	add	esi, 2
	add	edx, 3
	add	ecx, eax
	add	edi, eax
	add	esi, eax
	add	edx, eax
	add	eax, 4
	cmp	eax, 100				; 00000064H
	jl	SHORT $LL7@main
	lea	eax, DWORD PTR [edx+esi]
	add	eax, edi
	add	ecx, eax

; 66   : 	TWONOPS

	npad	1
	npad	1

; 67   : 
; 68   : 	printf("%d\n", rc); // Protects against removal of strlen by the optimizer, but not part of your exercise

	push	ecx
	push	OFFSET ??_C@_03PMGGPEJJ@?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 8

; 131  : 		q4();
; 132  : 		q5();

	call	?q5@@YAHXZ				; q5

; 133  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END
